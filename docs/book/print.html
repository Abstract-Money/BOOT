<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>cw-orchestrator documentation</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="intro.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="quick_start.html"><strong aria-hidden="true">2.</strong> Quick-start</a></li><li class="chapter-item expanded "><a href="single_contract/index.html"><strong aria-hidden="true">3.</strong> Tutorial: Contract</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="single_contract/interfaces.html"><strong aria-hidden="true">3.1.</strong> Interfaces</a></li><li class="chapter-item expanded "><a href="single_contract/env-variable.html"><strong aria-hidden="true">3.2.</strong> Environment Vars</a></li><li class="chapter-item expanded "><a href="single_contract/scripting.html"><strong aria-hidden="true">3.3.</strong> Scripting</a></li><li class="chapter-item expanded "><a href="single_contract/integration-tests.html"><strong aria-hidden="true">3.4.</strong> Integration Tests</a></li></ol></li><li class="chapter-item expanded "><a href="workspace/index.html"><strong aria-hidden="true">4.</strong> Tutorial: Workspace</a></li><li class="chapter-item expanded "><a href="ci-cd.html"><strong aria-hidden="true">5.</strong> CI/CD</a></li><li class="chapter-item expanded "><a href="contributing.html"><strong aria-hidden="true">6.</strong> Contributing</a></li><li class="chapter-item expanded "><a href="references.html"><strong aria-hidden="true">7.</strong> References</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">cw-orchestrator documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="cw-orchestrator"><a class="header" href="#cw-orchestrator">Cw-Orchestrator</a></h1>
<p>cw-orchestrator is an advanced testing and deployment tool for CosmWasm smart-contracts. It's designed to make it easy to test and deploy contracts in a variety of environments including cw-multi-test, local, testnet, and mainnet. It does this by providing the ability to write environment-generic code that interacts with CosmWasm contracts and by doing so removing the need to keep maintain deployment code for multiple environments. In short, cw-orchestrator should be your go-to tool for testing and deploying CosmWasm contracts.</p>
<h2 id="features"><a class="header" href="#features">Features</a></h2>
<ul>
<li>
<p><strong>Testing</strong>: cw-orchestrator provides a testing framework that makes it easy to write tests for CosmWasm contracts. It does this by providing a testing environment that mimics the behavior of a CosmWasm blockchain. This allows you to write tests that interact with your contract in the same way that it would be interacted with on a real blockchain. These kinds of tests allow developers to more easily test contract-to-contract interactions without having to deal with the overhead of running a local node. The testing framework also provides a number of utilities that make it easy to write tests for CosmWasm contracts. These utilities include the ability to easily set and query balances, set block height/time and more. Additionally by creating a wrapper interface around a project's deployment developers can share their testing infrastructure with other developers, allowing them to easily test how their contracts interact with the project.</p>
</li>
<li>
<p><strong>Deployment</strong>: cw-orchestrator also provides the ability to deploy to real networks. It does this by providing an easy to use interface to a blockchain node that can be used to submit transactions, query state and inspect transaction results.</p>
</li>
<li>
<p><strong>Interface Generation</strong>: Interacting with a smart-contract is often verbose, leading to a lot of boilerplate code. cw-orchestrator solves this problem by providing a macro that generates an interface to a contract. This interface can be used to easily interact with a contract and improves the readability of your tests and deployments. Making it easier to write and maintain tests and deployments. Additionally, because this library is written in Rust, any breaking changes to your contract's interface will cause a compile-time error, making it easy to keep your tests and deployments up to date.</p>
</li>
</ul>
<h2 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h2>
<p>These docs contain a quick-start and a longer tutorial-style walkthrough.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quick-start-guide"><a class="header" href="#quick-start-guide">Quick-Start Guide</a></h1>
<p>This guide will show you how to use the <code>cw-orchestrator</code> with your smart contract. Follow the steps below to add <code>cw-orch</code> to your contract's TOML file, enable the interface feature, add the interface macro to your contract's endpoints, and use interaction helpers to simplify contract calls and queries.</p>
<h2 id="adding-cw-orch-to-your-cargotoml-file"><a class="header" href="#adding-cw-orch-to-your-cargotoml-file">Adding <code>cw-orch</code> to Your <code>Cargo.toml</code> File</a></h2>
<p>To use the <code>cw-orchestrator</code>, you need to add <code>cw-orch</code> to your contract's TOML file. Run the command below in your contract's directory:</p>
<pre><code class="language-shell">$ cargo add --optional cw-orch
&gt; Adding cw-orch v0.10.0 to optional dependencies.
</code></pre>
<p>Alternatively, you can add it manually in your <code>Cargo.toml</code> file as shown below:</p>
<pre><code class="language-toml">[dependencies]
cw-orch = {version = &quot;0.11.0&quot;, optional = true } # Latest version at time of writing
</code></pre>
<p>Now that we have added <code>cw-orch</code> as an optional dependency we will want to enable it through a feature. This ensures that the code added by <code>cw-orch</code> is not included in the wasm artifact of the contract. To do this add an <code>interface</code> feature to the <code>Cargo.toml</code> and enable <code>cw-orch</code> when it is enabled.</p>
<p>To do this include the following in the <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[features]
interface = [&quot;dep:cw-orch&quot;] # Adds the dependency when the feature is enabled
</code></pre>
<h2 id="creating-an-interface"><a class="header" href="#creating-an-interface">Creating an Interface</a></h2>
<p>Now that we have the dependency set up you can add the <code>interface_entry_point</code> macro to your contract's entry points. This macro will generate an interface to your contract that you will be able to use to interact with your contract. Get started by adding the feature-flagged interface macro to the contract's entry points:</p>
<pre><code class="language-rust no_run noplayground"><span class="boring">use cosmwasm_std::{DepsMut, Env, MessageInfo, Response, StdResult};
</span><span class="boring">pub struct InstantiateMsg;
</span><span class="boring">pub struct ExecuteMsg;
</span><span class="boring">
</span>// In `contract.rs`
#[cfg_attr(feature=&quot;interface&quot;, cw_orch::interface_entry_point)] // &lt;--- Add this line
pub fn instantiate(
   deps: DepsMut,
   env: Env,
   info: MessageInfo,
   msg: InstantiateMsg,
) -&gt; StdResult&lt;Response&gt; {
    // ...
    Ok(Response::new())
}

#[cfg_attr(feature=&quot;interface&quot;, cw_orch::interface_entry_point)] // &lt;--- Add this line
pub fn execute(
   deps: DepsMut,
   env: Env,
   info: MessageInfo,
   msg: ExecuteMsg,
) -&gt; StdResult&lt;Response&gt; {
    // ...
    Ok(Response::new())
}
<span class="boring">
</span><span class="boring">fn main() {}
</span>// ... Do the same for the other entry points (query, migrate, reply, sudo)</code></pre>
<p>By adding these lines, we generate code whenever the <code>interface</code> feature is enabled. The code generates a contract interface, the name of which will be the PascalCase of the crate's name.</p>
<p>When uploading to a blockchain the marco will search for an <code>artifacts</code> directory in the project's root. If this is not what you want you can specify the paths yourself using the <code>interface</code> macro covered in <a href="./tutorial/interfaces.html#defining-contract-interfaces">interfaces</a>.</p>
<blockquote>
<p>The name of the crate is defined in the <code>Cargo.toml</code> file of your contract.</p>
</blockquote>
<p>It can be helpful to re-expose the interface in the crate's root so that it is easy to import:</p>
<pre><code class="language-rust ignore">// in lib.rs
#[cfg(feature = &quot;interface&quot;)]
pub use crate::contract::MyContract</code></pre>
<p>You can now create a test in <code>contract/tests</code> or an executable in <code>contract/bin</code> and start interacting with the contract.</p>
<h2 id="interaction-helpers"><a class="header" href="#interaction-helpers">Interaction helpers</a></h2>
<p>cw-orchestrator provides an additional macro to simplify contract calls and queries. The macro generates functions on the interface for each variant of the contract's <code>ExecuteMsg</code> and <code>QueryMsg</code>.</p>
<p>Enabling this functionality is very straight-forward. Find your <code>ExecuteMsg</code> and <code>QueryMsg</code> definitions and add the <code>ExecuteFns</code> and <code>QueryFns</code> derive macros to them like below:</p>
<pre><pre class="playground"><code class="language-rust no_run">use cosmwasm_schema::{QueryResponses, cw_serde};

#[cfg_attr(feature = &quot;interface&quot;, derive(cw_orch::ExecuteFns))]
#[cw_serde]
pub enum ExecuteMsg {
    Increment {},
    // ...
}

#[cfg_attr(feature = &quot;interface&quot;, derive(cw_orch::QueryFns))]
#[derive(QueryResponses)]
#[cw_serde]
pub enum QueryMsg {
    #[returns(String)]
    Config {}
    // ...
}

<span class="boring">fn main() {}</span></code></pre></pre>
<p>Any variant of the <code>ExecuteMsg</code> and <code>QueryMsg</code> that has a <code>#[derive(ExecuteFns)]</code> or <code>#[derive(QueryFns)]</code> will have a function implemented on the interface through a trait. The function will have the snake_case name of the variant and will take the same arguments as the variant. The arguments are ordered in alphabetical order to prevent attribute ordering from changing the function signature. If coins need to be sent along with the message you can add <code>#[payable]</code> to the variant and the function will take a <code>Vec&lt;Coin&gt;</code> as the last argument.</p>
<p>You can access these functions by importing the generated traits form the message file. The generated traits are named <code>ExecuteMsgFns</code> and <code>QueryMsgFns</code>. Again it's helpful to re-export these traits in the crate's root so that they are easy to import:</p>
<pre><code class="language-rust ignore">// in lib.rs
#[cfg(feature = &quot;interface&quot;)]
pub use crate::msg::{ExecuteMsgFns as MyContractExecuteFns, QueryMsgFns as MyContractQueryFns};</code></pre>
<h2 id="example-counter-contract"><a class="header" href="#example-counter-contract">Example Counter Contract</a></h2>
<p>To show all this functionality in action, we will use an example counter contract. The example counter contract is a simple contract that allows you to increment and decrement a counter. The contract also allows you to query the current value of the counter. The contract is available <a href="https://github.com/AbstractSDK/cw-orchestrator/tree/main/contracts/counter">here</a>.</p>
<p>We have already added the <code>interface_entry_point</code> macro to the contract's endpoints. We can now create a test in <code>contract/tests</code> to interact with the contract. The test will use the <code>Mock</code> struct from <code>cw-orchestrator</code> to mock the environment and the <code>CounterContract</code> struct generated by the <code>interface_entry_point</code> macro to interact with the contract.</p>
<pre><code class="language-rust ignore">/// Instantiate the contract in any CosmWasm environment
fn setup&lt;Chain: CwEnv&gt;(chain: Chain) -&gt; CounterContract&lt;Chain&gt; {
    // Construct the counter interface
    let contract = CounterContract::new(CONTRACT_NAME, chain.clone());
    let admin = Addr::unchecked(ADMIN);

    // Upload the contract
    let upload_resp = contract.upload().unwrap();

    // Get the code-id from the response.
    let code_id = upload_resp.uploaded_code_id().unwrap();
    // or get it from the interface.
    assert_eq!(code_id, contract.code_id().unwrap());

    // Instantiate the contract
    let msg = InstantiateMsg { count: 1i32 };
    let init_resp = contract.instantiate(&amp;msg, Some(&amp;admin), None).unwrap();

    // Get the address from the response
    let contract_addr = init_resp.instantiated_contract_address().unwrap();
    // or get it from the interface.
    assert_eq!(contract_addr, contract.address().unwrap());

    // Return the interface
    contract
}

#[test]
fn count() {
    // Create a sender
    let sender = Addr::unchecked(ADMIN);
    // Create the mock
    let mock = Mock::new(&amp;sender);

    // Set up the contract
    let contract = setup(mock.clone());

    // Increment the count of the contract
    contract
        // Set the caller to user
        .call_as(&amp;Addr::unchecked(USER))
        // Call the increment function (auto-generated function provided by CounterExecuteMsgFns)
        .increment()
        .unwrap();

    // Get the count.
    use counter_contract::CounterQueryMsgFns;
    let count1 = contract.get_count().unwrap();

    // or query it manually
    let count2: GetCountResponse = contract.query(&amp;QueryMsg::GetCount {}).unwrap();

    assert_eq!(count1, count2);

    // Check the count
    assert_eq!(count1.count, 2);
    // Reset
    use counter_contract::CounterExecuteMsgFns;
    contract.reset(0).unwrap();

    let count = contract.get_count().unwrap();
    assert_eq!(count.count, 0);
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tutorial"><a class="header" href="#tutorial">Tutorial</a></h1>
<p>This tutorial will guide you through setting up a single contract for use with cw-orchestrator. By the end of this tutorial you should be able to:</p>
<ul>
<li>Write deployment scripts for your contract.</li>
<li>Write integration tests for your contract.</li>
<li>Write executables for interacting with your contract.</li>
</ul>
<p>In order to ensure that the code snippets shown here are correct we'll be using the counter contract provided in the repository as the source for our code-snippets. You can find the contract <a href="https://github.com/AbstractSDK/cw-orchestrator/tree/main/contracts/counter">here</a>.</p>
<blockquote>
<p>If you're working within a cargo workspace environment you can follow along and read the <a href="single_contract/../workspace/index.html">Workspace</a> docs after this tutorial.</p>
</blockquote>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<ul>
<li>
<p>Contract Entry Point Messages: In order to use cw-orchestrator you need access to the entry point message types (<code>InstantiateMsg</code>,<code>ExecuteMsg</code>,...) of the contracts you want to interact with. Having them locally will enable you to generate helper functions for interacting with the contracts.</p>
</li>
<li>
<p>A gRPC endpoint (optional): If you want to perform on-chain transaction you will need access to the gRPC endpoint of a node. These are most-often available on port 9090. Look in the documentation of the chain you want to connect to if our defaults aren't sufficient, or use the <a href="https://cosmos.directory">Cosmos Directory</a> implementation to query one.</p>
</li>
<li>
<p>A desire to learn: This tutorial will cover the basics of using cw-orchestrator but it won't cover everything. If you want to learn more about the features of cw-orchestrator you can check out the <a href="https://docs.rs/cw-orch/latest/cw_orch/">API Documentation</a>.</p>
</li>
</ul>
<p>The following sections detail setting up a contract, tests for the contract, and scripts for interacting with the contract on a blockchain network.</p>
<p>Following this example, the directory structure should eventually look like:</p>
<pre><code class="language-path">.
├── Cargo.toml
├── artifacts
│   └── counter.wasm (binary file)
└── counter
    ├── Cargo.toml
    ├── bin
    │   └── deploy.rs
    └── src
        ├── contract.rs (execute, instantiate, query, ...)
        └── msg.rs
        └── ..

</code></pre>
<h2 id="sections"><a class="header" href="#sections">Sections</a></h2>
<ul>
<li><strong><a href="single_contract/./interfaces.html">Interfaces</a></strong>
<ul>
<li>Define interfaces for your contracts.</li>
</ul>
</li>
<li><strong><a href="single_contract/./env-variable.html">Environment File</a></strong>
<ul>
<li>Configure your mnemonics and log settings.</li>
</ul>
</li>
<li><strong><a href="single_contract/./scripting.html">Scripting</a></strong>
<ul>
<li>Write runnable scripts with your interfaces.</li>
</ul>
</li>
<li><strong><a href="single_contract/./integration-tests.html">Integration Tests</a></strong>
<ul>
<li>Write an integration test for your contract.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interfaces"><a class="header" href="#interfaces">Interfaces</a></h1>
<p>Interfaces are virtual wrappers around CosmWasm contracts. They allow you to interact with your contracts in a type-safe way, and provide a convenient way to reason about contract interactions. Interfaces are the core reason why we built cw-orchestrator and we hope that you'll find them as useful as we do.</p>
<h2 id="setup"><a class="header" href="#setup">Setup</a></h2>
<p>Before we can create an interface we need to add cw-orch to the contract's <code>Cargo.toml</code> file. In <code>counter</code> run:</p>
<pre><code class="language-shell">$ cargo add --optional cw-orch
&gt; Adding cw-orch v0.11.0 to optional dependencies.
</code></pre>
<p>or add it manually to the <code>counter/Cargo.toml</code> file:</p>
<pre><code class="language-toml">[dependencies]
cw-orch = {version = &quot;0.11.0&quot;, optional = true } # Latest version at time of writing
</code></pre>
<p>We add <code>cw-orch</code> as an optional dependency to ensure that it is not included in the wasm artifact of the contract. This way there are no trust assumptions made about the code added by <code>cw-orch</code>, making it safe to use for production contracts.</p>
<p>However, we will need a way to enable the dependency when we want to use it. To do this add an <code>interface</code> feature to the <code>Cargo.toml</code> and enable <code>cw-orch</code> when it is enabled.</p>
<p>You can do this by including the following in the <code>counter/Cargo.toml</code>:</p>
<pre><code class="language-toml">[features]
interface = [&quot;dep:cw-orch&quot;] # Adds the dependency when the feature is enabled
</code></pre>
<p>Features (aka. feature flags) are a way to enable or disable parts of your code. In this case, we are including <code>cw-orch</code> as a dependency when the <code>interface</code> feature is enabled. This is a common pattern for feature flags.</p>
<h2 id="creating-an-interface-1"><a class="header" href="#creating-an-interface-1">Creating an Interface</a></h2>
<p>Now that we have our dependency set up we can create the interface. <code>cw-orch</code> provides two methods to easily create an interface for your contract.</p>
<p>The first is the <code>interface_entry_point</code> macro. This macro will generate an interface for your contract by calling it at the entry points of your contract. We'll cover this macro first as it's the easiest to use.</p>
<p>Alternatively you can also use the <code>interface</code> macro. This macro is more flexible and allows you to create an interface for your contract without having to call it at the entry points, as well as the ability to specify the contract's source more easily. We'll cover this macro in the end of this section.</p>
<h3 id="entry-point-macro"><a class="header" href="#entry-point-macro">Entry Point Macro</a></h3>
<p>As mentioned this macro is the easiest to use. It will generate an interface for your contract by calling it at the entry points of your contract. Here's an example of how to use it.</p>
<p>In <code>counter/src/contract.rs</code>:</p>
<pre><code class="language-rust ignore">#[cfg_attr(feature = &quot;export&quot;, entry_point)]
#[cfg_attr(feature = &quot;interface&quot;, cw_orch::interface_entry_point)]
pub fn instantiate(
    deps: DepsMut,
    _env: Env,
    info: MessageInfo,
    msg: InstantiateMsg,
) -&gt; Result&lt;Response, ContractError&gt; {
    let state = State {
        count: msg.count,
        owner: info.sender.clone(),
    };
    set_contract_version(deps.storage, CONTRACT_NAME, CONTRACT_VERSION)?;
    STATE.save(deps.storage, &amp;state)?;

    Ok(Response::new()
        .add_attribute(&quot;method&quot;, &quot;instantiate&quot;)
        .add_attribute(&quot;owner&quot;, info.sender)
        .add_attribute(&quot;count&quot;, msg.count.to_string()))
}

#[cfg_attr(feature = &quot;export&quot;, entry_point)]
#[cfg_attr(feature = &quot;interface&quot;, cw_orch::interface_entry_point)]
pub fn execute(
    deps: DepsMut,
    _env: Env,
    info: MessageInfo,
    msg: ExecuteMsg,
) -&gt; Result&lt;Response, ContractError&gt; {
    match msg {
        ExecuteMsg::Increment {} =&gt; execute::increment(deps),
        ExecuteMsg::Reset { count } =&gt; execute::reset(deps, info, count),
    }
}

#[cfg_attr(feature = &quot;export&quot;, entry_point)]
#[cfg_attr(feature = &quot;interface&quot;, cw_orch::interface_entry_point)]
pub fn query(deps: Deps, _env: Env, msg: QueryMsg) -&gt; StdResult&lt;Binary&gt; {
    match msg {
        QueryMsg::GetCount {} =&gt; to_binary(&amp;query::count(deps)?),
    }
}

#[cfg_attr(feature = &quot;export&quot;, entry_point)]
#[cfg_attr(feature = &quot;interface&quot;, cw_orch::interface_entry_point)]
pub fn migrate(_deps: DepsMut, _env: Env, _msg: MigrateMsg) -&gt; Result&lt;Response, ContractError&gt; {
    Ok(Response::default().add_attribute(&quot;action&quot;, &quot;migrate&quot;))
}</code></pre>
<p>Most of this should look familiar but if you're wondering about the two lines that contain <code>#[...]</code> here's what they do:</p>
<ol>
<li>
<pre><code class="language-rust ignore">#[cfg_attr(feature = &quot;export&quot;, entry_point)]</code></pre>
<p>This is a CosmWasm macro. It enables the Wasm runtime to call into the function. You can read more about the macro in the <a href="https://book.cosmwasm.com/basics/entry-points.html">CosmWasm book</a>. We only enable this macro when the <code>export</code> feature is enabled. This prevents conflicts with other entry points when the contract is a dependency of another contract.</p>
</li>
<li>
<pre><code class="language-rust ignore">#[cfg_attr(feature = &quot;interface&quot;, cw_orch::interface_entry_point)]</code></pre>
<p>This is the cw-orch provided macro. It will generate an interface for your contract by analyzing the messages passed to the entry points. This is possible because the entry point function definitions have strict parameter requirements. With this information the macro can generate a type safe interface for your contract. We only enable this macro when the <code>interface</code> feature is enabled.</p>
</li>
</ol>
<h3 id="customizable-interface-macro"><a class="header" href="#customizable-interface-macro">Customizable Interface Macro</a></h3>
<p>The second method to create an interface is the <code>interface</code> macro. To use it, first create a new file in the <code>contract/src</code> directory called <code>interface.rs</code>. This is where we will expose our interface.</p>
<p>In <code>counter/src/lib.rs</code>:</p>
<pre><code class="language-rust ignore">#[cfg(feature = &quot;interface&quot;)]
mod interface;</code></pre>
<p>Then in <code>counter/src/interface.rs</code>:</p>
<pre><code class="language-rust ignore">use cw_orch::{
    anyhow::Result,
    interface,
    prelude::{queriers::Node, *},
};

use crate::{
    contract::CONTRACT_NAME,
    msg::{ExecuteMsg, InstantiateMsg, MigrateMsg, QueryMsg},
    CounterContract,
};

#[interface(InstantiateMsg, ExecuteMsg, QueryMsg, MigrateMsg)]
pub struct Counter;

impl&lt;Chain: CwEnv&gt; Uploadable for Counter&lt;Chain&gt; {
    // Return the path to the wasm file
    fn wasm(&amp;self) -&gt; WasmPath {
        let crate_path = env!(&quot;CARGO_MANIFEST_DIR&quot;);
        let wasm_path = format!(&quot;{}/../artifacts/{}&quot;, crate_path, &quot;mock.wasm&quot;);

        WasmPath::new(wasm_path).unwrap()
    }
    // Return a CosmWasm contract wrapper
    fn wrapper(&amp;self) -&gt; Box&lt;dyn MockContract&lt;Empty&gt;&gt; {
        Box::new(
            ContractWrapper::new_with_empty(
                crate::contract::execute,
                crate::contract::instantiate,
                crate::contract::query,
            )
            .with_migrate(crate::contract::migrate),
        )
    }
}</code></pre>
<p>This use of the <code>interface</code> macro even allows you to have generic arguments in the message types. Any generics will be added to the interface under a <code>PhantomData</code> attribute.</p>
<h2 id="constructor"><a class="header" href="#constructor">Constructor</a></h2>
<p>Both macros implement a <code>new</code> function on the interface:</p>
<pre><code class="language-rust ignore">    // Construct the counter interface
    let contract = CounterContract::new(CONTRACT_NAME, chain.clone());</code></pre>
<p>The constructor takes two arguments:</p>
<ol>
<li><code>contract_id</code>: The unique identifier for this contract. This is used as the key when retrieving address and code_id information for the contract.</li>
<li><code>chain</code>: The CosmWasm supported environment to use when calling the contract. Also includes the default sender information that will be used to call the contract.</li>
</ol>
<h2 id="custom-functions"><a class="header" href="#custom-functions">Custom Functions</a></h2>
<p>Now you can start implementing custom functions for your interfaces with ensured type safety.</p>
<p>The environments that are currently supported are:</p>
<ol>
<li><a href="https://crates.io/crates/cw-multi-test">cw-multi-test</a> by using <a href="https://docs.rs/cw-orch/latest/cw_orch/prelude/struct.Mock.html"><code>Mock</code></a> as the environment.</li>
<li>Blockchain daemons like <a href="https://github.com/CosmosContracts/juno">junod</a>, <a href="https://github.com/osmosis-labs/osmosis">osmosisd</a>, etc. These use the <a href="https://docs.rs/cw-orch/latest/cw_orch/prelude/struct.Daemon.html"><code>Daemon</code></a> environment.</li>
</ol>
<h3 id="generic-function"><a class="header" href="#generic-function">Generic function</a></h3>
<p>Generic functions can be executed over any environment. Setup functions are a good example of this.</p>
<pre><code class="language-rust ignore">/// Instantiate the contract in any CosmWasm environment
fn setup&lt;Chain: CwEnv&gt;(chain: Chain) -&gt; CounterContract&lt;Chain&gt; {
    // Construct the counter interface
    let contract = CounterContract::new(CONTRACT_NAME, chain.clone());
    let admin = Addr::unchecked(ADMIN);

    // Upload the contract
    let upload_resp = contract.upload().unwrap();

    // Get the code-id from the response.
    let code_id = upload_resp.uploaded_code_id().unwrap();
    // or get it from the interface.
    assert_eq!(code_id, contract.code_id().unwrap());

    // Instantiate the contract
    let msg = InstantiateMsg { count: 1i32 };
    let init_resp = contract.instantiate(&amp;msg, Some(&amp;admin), None).unwrap();

    // Get the address from the response
    let contract_addr = init_resp.instantiated_contract_address().unwrap();
    // or get it from the interface.
    assert_eq!(contract_addr, contract.address().unwrap());

    // Return the interface
    contract
}</code></pre>
<h3 id="daemon-only-functions"><a class="header" href="#daemon-only-functions">Daemon-only functions</a></h3>
<pre><code class="language-rust ignore">impl Counter&lt;Daemon&gt; {
    /// Deploys the counter contract at a specific block height
    pub fn await_launch(&amp;self) -&gt; Result&lt;()&gt; {
        let daemon = self.get_chain();
        let rt = daemon.rt_handle.clone();

        rt.block_on(async {
            // Get the node query client, there are a lot of other clients available.
            let node = daemon.query_client::&lt;Node&gt;();
            let mut latest_block = node.latest_block().await.unwrap();

            while latest_block.header.height.value() &lt; 100 {
                // wait for the next block
                daemon.next_block().unwrap();
                latest_block = node.latest_block().await.unwrap();
            }
        });

        let contract = CounterContract::new(CONTRACT_NAME, daemon.clone());

        // Upload the contract
        contract.upload().unwrap();

        // Instantiate the contract
        let msg = InstantiateMsg { count: 1i32 };
        contract.instantiate(&amp;msg, None, None).unwrap();

        Ok(())
    }
}</code></pre>
<h2 id="entry-point-function-generation"><a class="header" href="#entry-point-function-generation">Entry Point Function Generation</a></h2>
<p>Contract execution and querying is so common that we felt the need to improve the method of calling them. To do this we created two macros: <code>ExecuteFns</code> and <code>QueryFns</code>. As their name implies they can be used to automatically generate functions for executing and querying your contract through the interface.</p>
<h3 id="execution"><a class="header" href="#execution">Execution</a></h3>
<p>To get started, find the <code>ExecuteMsg</code> definition for your contract. In our case it's located in <code>contracts/counter/src/msg.rs</code>. Then add the following line to your <code>ExecuteMsg</code> enum:</p>
<pre><code class="language-rust ignore">#[cw_serde]
#[cfg_attr(feature = &quot;interface&quot;, derive(cw_orch::ExecuteFns))] // Function generation
pub enum ExecuteMsg {
    Increment {},
    Reset { count: i32 },
}</code></pre>
<p>Again we feature flag the function generation to prevent cw-orchestrator entering as a dependency when building your contract.</p>
<p>The functions are implemented as a trait named <code>ExecuteMsgFns</code> which is implemented on any interface that uses this <code>ExecuteMsg</code>.</p>
<p>Using the trait then becomes as simple as:</p>
<pre><code class="language-rust ignore">// in integration_tests.rs
    // Reset
    use counter_contract::CounterExecuteMsgFns;
    contract.reset(0).unwrap();

    let count = contract.get_count().unwrap();
    assert_eq!(count.count, 0);</code></pre>
<h3 id="query"><a class="header" href="#query">Query</a></h3>
<p>Generating query functions is a similar process but has the added advantage of using the <code>cosmwasm-schema</code> return tags to detect the query's return type. This allows for type-safe query functions!</p>
<pre><code class="language-rust ignore">#[cw_serde]
#[cfg_attr(feature = &quot;interface&quot;, derive(cw_orch::QueryFns))] // Function generation
#[derive(QueryResponses)]
pub enum QueryMsg {
    // GetCount returns the current count as a json-encoded number
    #[returns(GetCountResponse)]
    GetCount {},
}

// Custom response for the query
#[cw_serde]
pub struct GetCountResponse {
    pub count: i32,
}</code></pre>
<p>Using it is just as simple as the execution functions:</p>
<pre><code class="language-rust ignore">// in integration_tests.rs
    // Get the count.
    use counter_contract::CounterQueryMsgFns;
    let count1 = contract.get_count().unwrap();</code></pre>
<p>Just like the interface it can be beneficial to re-export the trait in your <code>lib.rs</code> or <code>interface.rs</code> file.</p>
<p>In the counter contract we re-export in <code>lib.rs</code>;</p>
<pre><code class="language-rust ignore">#[cfg(feature = &quot;interface&quot;)]
pub use crate::msg::{ExecuteMsgFns as CounterExecuteMsgFns, QueryMsgFns as CounterQueryMsgFns};</code></pre>
<h2 id="learn-more"><a class="header" href="#learn-more">Learn more</a></h2>
<p>Got questions? Join the <a href="https://discord.gg/vAQVnz3tzj">Abstract Discord</a> and ask in the <code>#cw-orchestrator</code> channel.
Learn more about Abstract at <a href="https://abstract.money">abstract.money</a>.</p>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<ul>
<li><a href="https://crates.io/crates/cw-orch">cw-orchestrator</a></li>
<li><a href="https://crates.io/crates/cw-plus-orc">cw-plus-orc</a></li>
<li><a href="https://crates.io/crates/abstract-cw-orch">Abstract Contract Interfaces</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="environment-variables"><a class="header" href="#environment-variables">Environment Variables</a></h1>
<p>cw-orch needs some environment variables to be set in order to function properly when running as an executable.</p>
<p><strong>IMPORTANT: Before proceeding, ensure that you add <code>.env</code> to your <code>.gitignore</code>. We are not responsible for any loss of funds due to leaked mnemonics.</strong></p>
<p>Here are the optional environment variables:</p>
<pre><code class="language-bash"># .env

# info, debug, trace (if using env_logger for logging)
RUST_LOG=info

# Where the contract wasms are located (used by ArtifactsDir::env())
ARTIFACTS_DIR=&quot;../artifacts&quot;

# where to store the state of your deployments (default: ./state.json)
STATE_FILE=&quot;./daemon_state.json&quot;

# Mnemonics of the account that will be used to sign transactions
# Can optionally be set on DaemonBuilder as well.
LOCAL_MNEMONIC=&quot;&quot;
TEST_MNEMONIC=&quot;&quot;
MAIN_MNEMONIC=&quot;&quot;
</code></pre>
<h2 id="mnemonics"><a class="header" href="#mnemonics">Mnemonics</a></h2>
<p><strong>Only 24-word mnemonics are supported at this time.</strong> If you're experienced with keychain and private key management we'd really appreciate your help in adding support for other formats. Please reach out to us on <a href="https://discord.gg/uch3Tq3aym">Discord</a> if you're interested in helping out.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="writing-and-executing-scripts"><a class="header" href="#writing-and-executing-scripts">Writing and Executing Scripts</a></h1>
<p>Now that we have the interface written for our contract, we can start writing scripts to deploy and interact with it on a real blockchain. We'll do this by adding a <code>examples</code> folder in our contract and add our deploy script there.</p>
<h2 id="setup-1"><a class="header" href="#setup-1">Setup</a></h2>
<p>Before we get going we need to add the <code>examples</code> folder and tell cargo that it contains scripts. We can do this by creating a folder named examples in <code>counter</code> and creating a file in it called <code>deploy.rs</code></p>
<pre><code class="language-bash">mkdir counter/examples
touch counter/examples/deploy.rs
</code></pre>
<p>Then we want to add the required dependencies to the <code>dev-dependencies</code> section of our <code>Cargo.toml</code> file. We'll need <code>dotenv</code> to load our environment variables and <code>env_logger</code> to log to stdout. We're using <code>examples</code> instead of <code>bin</code> because setting a feature on an optional dependency is not supported.</p>
<pre><code class="language-toml">[dev-dependencies]
# Deps for deployment
dotenv = { version = &quot;0.15.0&quot; } # Enables loading of .env files
env_logger = { version = &quot;0.10.0&quot; } # Enables logging to stdout
</code></pre>
<p>Finally, we need to add the examples to our <code>Cargo.toml</code> file. Add put a feature requirement on it:</p>
<pre><code class="language-toml">[[example]]
name = &quot;deploy&quot;
path = &quot;examples/deploy.rs&quot;
</code></pre>
<p>Now we're ready to start writing our script.</p>
<h2 id="main-function"><a class="header" href="#main-function">Main Function</a></h2>
<p>With the setup done, we can start writing our script. Our initial plan is to deploy the counter contract to the chain. We'll start by writing a main function that will call our deploy function.</p>
<pre><code class="language-rust ignore">use counter_contract::{msg::InstantiateMsg, CounterContract};
use cw_orch::{anyhow, prelude::*, tokio};
use tokio::runtime::Runtime;

/// Script that registers the first Account in abstract (our Account)
pub fn main() -&gt; anyhow::Result&lt;()&gt; {
    dotenv::dotenv().ok();
    env_logger::init();

    let rt = Runtime::new()?;
    let network = networks::LOCAL_JUNO;
    let chain = DaemonBuilder::default()
        .handle(rt.handle())
        .chain(network)
        .build()?;

    let counter = CounterContract::new(&quot;counter_contract&quot;, chain);

    counter.upload()?;
    counter.instantiate(&amp;InstantiateMsg { count: 0 }, None, None)?;
    Ok(())
}</code></pre>
<h2 id="synchronous-daemon"><a class="header" href="#synchronous-daemon">Synchronous Daemon</a></h2>
<h2 id="asynchronous-daemon"><a class="header" href="#asynchronous-daemon">Asynchronous Daemon</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="integration-tests"><a class="header" href="#integration-tests">Integration Tests</a></h1>
<p>Integration tests are very easy to write with cw-orch. Start by creating a <code>tests</code> folder in your contract's dir.</p>
<pre><code class="language-bash">mkdir counter/tests
</code></pre>
<p>Then create a file called <code>integration_tests.rs</code> in the <code>tests</code> folder.</p>
<pre><code class="language-bash">touch counter/tests/integration_tests.rs
</code></pre>
<p>Now we can write our tests. Here's an example of a test that deploys the contract, increments the counter and then resets it.</p>
<pre><code class="language-rust ignore">use counter_contract::{
    contract::CONTRACT_NAME,
    msg::{GetCountResponse, InstantiateMsg, QueryMsg},
    CounterContract,
};
// Use prelude to get all the necessary imports
use cw_orch::prelude::*;

use cosmwasm_std::Addr;

// consts for testing
const USER: &amp;str = &quot;user&quot;;
const ADMIN: &amp;str = &quot;admin&quot;;
/// Instantiate the contract in any CosmWasm environment
fn setup&lt;Chain: CwEnv&gt;(chain: Chain) -&gt; CounterContract&lt;Chain&gt; {
    // Construct the counter interface
    let contract = CounterContract::new(CONTRACT_NAME, chain.clone());
    let admin = Addr::unchecked(ADMIN);

    // Upload the contract
    let upload_resp = contract.upload().unwrap();

    // Get the code-id from the response.
    let code_id = upload_resp.uploaded_code_id().unwrap();
    // or get it from the interface.
    assert_eq!(code_id, contract.code_id().unwrap());

    // Instantiate the contract
    let msg = InstantiateMsg { count: 1i32 };
    let init_resp = contract.instantiate(&amp;msg, Some(&amp;admin), None).unwrap();

    // Get the address from the response
    let contract_addr = init_resp.instantiated_contract_address().unwrap();
    // or get it from the interface.
    assert_eq!(contract_addr, contract.address().unwrap());

    // Return the interface
    contract
}

#[test]
fn count() {
    // Create a sender
    let sender = Addr::unchecked(ADMIN);
    // Create the mock
    let mock = Mock::new(&amp;sender);

    // Set up the contract
    let contract = setup(mock.clone());

    // Increment the count of the contract
    contract
        // Set the caller to user
        .call_as(&amp;Addr::unchecked(USER))
        // Call the increment function (auto-generated function provided by CounterExecuteMsgFns)
        .increment()
        .unwrap();

    // Get the count.
    use counter_contract::CounterQueryMsgFns;
    let count1 = contract.get_count().unwrap();

    // or query it manually
    let count2: GetCountResponse = contract.query(&amp;QueryMsg::GetCount {}).unwrap();

    assert_eq!(count1, count2);

    // Check the count
    assert_eq!(count1.count, 2);
    // Reset
    use counter_contract::CounterExecuteMsgFns;
    contract.reset(0).unwrap();

    let count = contract.get_count().unwrap();
    assert_eq!(count.count, 0);
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="workspace-tutorial"><a class="header" href="#workspace-tutorial">Workspace Tutorial</a></h1>
<p><strong>WIP</strong></p>
<p>Following this example, the project's structure should look like:</p>
<pre><code class="language-path">.
├── Cargo.toml
├── artifacts
│   ├── other_contract.wasm
│   └── my_contract.wasm
├── contracts
│   ├── my-contract
│   │   ├── Cargo.toml
│   │   └── src
│   │       ├── contract.rs (execute, instantiate, query, ...)
│   │       └── ..
│   └── other-contract
│       └── ..
├── packages
│   ├── my-project (messages)
│   │   ├── Cargo.toml
│   │   └── src
│   │       ├── lib.rs
│   │       ├── my-contract.rs
│   │       ├── other-contract.rs
│   │       └── ..
│   └── my-project-interface (interface collection)
│       ├── Cargo.toml
│       └── src
│           ├── lib.rs
│           ├── my-project.rs
│           └── ..
└── scripts (executables)
    ├── .env
    ├── Cargo.toml
    └── src
        ├── deploy.rs
        └── test_project.rs
</code></pre>
<h2 id="sections-1"><a class="header" href="#sections-1">Sections</a></h2>
<ul>
<li><strong><a href="workspace/./interfaces.html">Interfaces</a></strong>
<ul>
<li>Define interfaces for your contracts.</li>
</ul>
</li>
<li><strong><a href="workspace/./scripting.html">Scripting</a></strong>
<ul>
<li>Write runnable scripts with your interfaces.</li>
</ul>
</li>
<li><strong><a href="workspace/./integration.html">Integration</a></strong>
<ul>
<li>Export a deployment of your application for use in integration testing.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="continuous-integration-and-deployment"><a class="header" href="#continuous-integration-and-deployment">Continuous Integration and Deployment</a></h1>
<p>One of the tools that can improve your developer productivity drastically is setting up pipelines for your contract deployments. </p>
<p>cw-orchestrator does not <em>currently</em> add additional support for actions, but an example using the directory structure specified in <a href="interfaces.html">interfaces</a> can be found below:</p>
<pre><code class="language-yaml"># .github/workflows/deploy.yml
---
name: Deploy Contracts  
on:  
  # https://docs.github.com/en/actions/reference/events-that-trigger-workflows#workflow_dispatch  
  workflow_dispatch:  
  push:  
    branches: [ 'mainline' ]  
    paths:  
      - 'contracts/src/**/*.rs'  
      - '.github/workflows/deploy.yml'  
  
env:
  VERSION_CONTROL_ADDRESS: juno16enwrxhdtsdk8mkkcaj37fgp37wz0r3err4hxfz52lcdyayexnxs4468mu  
  STATE_FILE: &quot;./daemon_state.json&quot;  
  ARTIFACTS_DIR: &quot;./target/wasm32-unknown-unknown/release&quot;  
  SCHEMA_DIR: &quot;./schema&quot;  
  
jobs:  
  deploy:  
    runs-on: ubuntu-latest  
    steps:  
      - uses: actions/checkout@v3  
      - uses: actions-rs/toolchain@v1  
        with:  
          toolchain: nightly  
          target: wasm32-unknown-unknown  
          override: true  
      - name: Run cargo wasm  
        uses: actions-rs/cargo@v1  
        with:  
          command: build  
          args: --package counter-app --release --target wasm32-unknown-unknown  
        env:  
          RUSTFLAGS: '-C link-arg=-s'  

      - name: Run deployment script  
        uses: actions-rs/cargo@v1  
        with:  
          command: run  
          args: --package scripts --bin deploy_app  
        env:  
          CHAIN: &quot;juno&quot;  
          DEPLOYMENT: &quot;debugging&quot;  
          NETWORK: &quot;local&quot;  
          RUST_LOG: info  
          ARTIFACTS_DIR: ${{ env.ARTIFACTS_DIR }}  
          STATE_FILE: ${{ env.STATE_FILE }}  
  
          VERSION_CONTROL_ADDRESS: ${{ env.VERSION_CONTROL_ADDRESS }}  
          TEST_MNEMONIC: ${{ secrets.TEST_MNEMONIC }}  

      - name: Upload deployment daemon state  
        uses: actions/upload-artifact@v2  
        with:  
          name: deployment.json  
          path: ${{ env.STATE_FILE }}  
      - name: Upload WASM  
        uses: actions/upload-artifact@v2  
        with:  
          # TODO: name env or from cargo  
          name: counter_app.wasm  
          path: ${{ env.ARTIFACTS_DIR }}/counter_app.wasm
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributing-to-cw-orchestrator"><a class="header" href="#contributing-to-cw-orchestrator">Contributing to cw-orchestrator</a></h1>
<p>Thank you for considering to contribute to the cw-orchestrator project! We appreciate your support and welcome contributions to help improve this multi-environment CosmWasm smart-contract scripting library. This document provides guidelines and instructions on how to contribute to the project effectively.</p>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of Contents</a></h2>
<ul>
<li><a href="contributing.html#code-of-conduct">Code of Conduct</a></li>
<li><a href="contributing.html#getting-started">Getting Started</a></li>
<li><a href="contributing.html#how-to-contribute">How to Contribute</a>
<ul>
<li><a href="contributing.html#reporting-bugs">Reporting Bugs</a></li>
<li><a href="contributing.html#suggesting-enhancements">Suggesting Enhancements</a></li>
<li><a href="contributing.html#code-contributions">Code Contributions</a>
<ul>
<li><a href="contributing.html#pull-requests">Pull Requests</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="contributing.html#style-guide">Style Guide</a></li>
<li><a href="contributing.html#community">Community</a></li>
</ul>
<h2 id="code-of-conduct"><a class="header" href="#code-of-conduct">Code of Conduct</a></h2>
<p>By participating in this project, you are expected to uphold our <a href="CODE_OF_CONDUCT.html">Code of Conduct</a>. Please read the Code of Conduct to ensure that you follow the community guidelines and contribute positively to the project.</p>
<h2 id="getting-started-1"><a class="header" href="#getting-started-1">Getting Started</a></h2>
<p>To get started with contributing to the cw-orchestrator project, you should first familiarize yourself with the repository structure and the codebase. Please read the project's <a href="https://github.com/AbstractSDK/cw-orchestrator/">README</a> to understand the purpose, features, and usage of the cw-orchestrator library as well as its <a href="https://orchestrator.abstract.money">documentation</a>.</p>
<h2 id="how-to-contribute"><a class="header" href="#how-to-contribute">How to Contribute</a></h2>
<p>There are multiple ways to contribute to the cw-orchestrator project, including reporting bugs, suggesting enhancements, and submitting code contributions.</p>
<h2 id="reporting-bugs"><a class="header" href="#reporting-bugs">Reporting Bugs</a></h2>
<p>If you encounter any bugs or issues while using the cw-orchestrator library, please report them by creating a new issue in the <a href="https://github.com/AbstractSDK/cw-orchestrator/issues">issue tracker</a>. When reporting a bug, please provide the following information:</p>
<ul>
<li>A clear and descriptive title</li>
<li>A detailed description of the issue, including steps to reproduce it</li>
<li>Any relevant logs, error messages, or screenshots</li>
<li>Information about your environment, such as the OS, software versions, and hardware specifications</li>
</ul>
<h2 id="suggesting-enhancements"><a class="header" href="#suggesting-enhancements">Suggesting Enhancements</a></h2>
<p>We welcome suggestions for new features or improvements to the existing functionality of the cw-orchestrator library. To suggest an enhancement, create a new issue in the <a href="https://github.com/AbstractSDK/cw-orchestrator/issues">issue tracker</a> with the following information:</p>
<ul>
<li>A clear and descriptive title</li>
<li>A detailed explanation of the proposed enhancement, including its benefits and potential use cases</li>
<li>If applicable, any examples or mockups of the proposed feature</li>
</ul>
<h2 id="code-contributions"><a class="header" href="#code-contributions">Code Contributions</a></h2>
<p>To contribute code to the cw-orchestrator project, please follow these steps:</p>
<ol>
<li>Fork the repository to your own GitHub account.</li>
<li>Clone your fork to your local machine.</li>
<li>Create a new branch for your changes using the <code>git checkout -b feature/your-feature-name</code> command.</li>
<li>Make your changes and commit them with a clear and concise commit message.</li>
<li>Push your branch to your fork on GitHub.</li>
<li>Create a new pull request against the main branch of the cw-orchestrator repository.</li>
</ol>
<h2 id="pull-requests"><a class="header" href="#pull-requests">Pull Requests</a></h2>
<p>When submitting a pull request, please make sure that your code follows the <a href="contributing.html#style-guide">Style Guide</a> and that all tests pass. Please provide a detailed description of your changes, including the motivation for the changes and any potential impact on the project. This will help maintainers review your pull request more effectively.</p>
<h2 id="style-guide"><a class="header" href="#style-guide">Style Guide</a></h2>
<p>The cw-orchestrator project follows the Rust coding style and conventions. Please ensure that your code adheres to these guidelines to maintain consistency and readability throughout the codebase.</p>
<ul>
<li>Use proper indentation (4 spaces) and consistent formatting (<code>cargo fmt</code>).</li>
<li>Write descriptive variable and function names.</li>
<li>Use comments to explain complex or non-obvious code.</li>
<li>Follow the <a href="https://rust-lang.github.io/api-guidelines/">Rust API Guidelines</a> for API design.</li>
<li>Add documentation for public functions, types, and modules.</li>
<li>Write <a href="https://doc.rust-lang.org/rustdoc/documentation-tests.html">doc tests</a>
for public functions and methods.</li>
</ul>
<h2 id="community"><a class="header" href="#community">Community</a></h2>
<p>To join the cw-orchestrator community, please join the <a href="https://discord.gg/uch3Tq3aym">Abstract Discord server</a> and the <code>#cw-orchestrator</code> channel. You can also follow the project on <a href="https://twitter.com/AbstractSDK">Twitter</a> and <a href="https://github.com/AbstractSDK">GitHub</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="references-1"><a class="header" href="#references-1">References</a></h1>
<p>Easy, right? Try building your contracts with <a href="https://abstract.money">Abstract</a> for the same experience with smart contracts.
Get started <a href="https://docs.abstract.money/building-on-abstract/writing-modules/writing-an-app">here</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
