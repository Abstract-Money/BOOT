use boot_core::*;
use boot_core::{networks::LOCAL_JUNO, DaemonOptionsBuilder};
use boot_cw_plus::{Cw20Base, Cw20ExecuteMsgFns, Cw20QueryMsgFns, CwPlus, CW20_BASE};
use cw20::Cw20Coin;
use std::sync::Arc;
use tokio::runtime::Runtime;

// shows how to deploy CwPlus to a real environment
// Requires a running local junod with grpc enabled
pub fn script() -> anyhow::Result<()> {
    // create the tokio runtime
    let rt = Arc::new(Runtime::new().unwrap());
    // use the cosmos chain registry for gRPC url sources.
    let _chain_data = rt.block_on(RegistryChainData::fetch("juno".into(), None))?;
    let options = DaemonOptionsBuilder::default()
        // or provide `chain_data`
        .network(LOCAL_JUNO)
        // specify a custom deployment ID
        .deployment_id("v0.1.0")
        .build()?;

    // get sender form .env file mnemonic
    let (sender, chain) = instantiate_daemon_env(&rt, options)?;
    // deploy the cw-plus contracts
    let cw_plus = CwPlus::deploy_on(chain.clone(), Empty {})?;
    // get the cw20_base contract
    let cw20_base = cw_plus.cw20_base;
    // instantiate an instance of it
    let cw20_init_msg = cw20_base::msg::InstantiateMsg {
        decimals: 6,
        name: "Test Token".to_string(),
        initial_balances: vec![Cw20Coin {
            address: sender.to_string(),
            amount: 1000000u128.into(),
        }],
        marketing: None,
        mint: None,
        symbol: "TEST".to_string(),
    };
    cw20_base.instantiate(&cw20_init_msg, None, None)?;

    // query balance after init
    // notice that this query is generated by the macro and not defined in the object itself!
    let balance = cw20_base.balance(sender.to_string())?;
    assert_eq!(balance.balance.u128(), 1000000u128.into());

    // transfer some tokens
    let bart = Addr::unchecked("bart");
    let resp = cw20_base.transfer(50000u128.into(), bart.to_string())?;
    // there are some helper functions on the response types as well.
    let action = resp.event_attr_value("wasm", "action")?;
    assert_eq!(action, "transfer");

    Ok(())
}

fn main() {
    dotenv().ok();
    env_logger::init();

    use dotenv::dotenv;

    if let Err(ref err) = script() {
        log::error!("{}", err);
        err.chain()
            .skip(1)
            .for_each(|cause| log::error!("because: {}", cause));
        ::std::process::exit(1);
    }
}
